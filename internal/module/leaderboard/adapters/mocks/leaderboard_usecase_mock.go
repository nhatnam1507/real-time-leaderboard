// Code generated by MockGen. DO NOT EDIT.
// Source: real-time-leaderboard/internal/module/leaderboard/application (interfaces: LeaderboardUseCase)
//
// Generated by this command:
//
//	mockgen -destination=../adapters/mocks/leaderboard_usecase_mock.go -package=mocks real-time-leaderboard/internal/module/leaderboard/application LeaderboardUseCase
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	domain "real-time-leaderboard/internal/module/leaderboard/domain"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockLeaderboardUseCase is a mock of LeaderboardUseCase interface.
type MockLeaderboardUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockLeaderboardUseCaseMockRecorder
	isgomock struct{}
}

// MockLeaderboardUseCaseMockRecorder is the mock recorder for MockLeaderboardUseCase.
type MockLeaderboardUseCaseMockRecorder struct {
	mock *MockLeaderboardUseCase
}

// NewMockLeaderboardUseCase creates a new mock instance.
func NewMockLeaderboardUseCase(ctrl *gomock.Controller) *MockLeaderboardUseCase {
	mock := &MockLeaderboardUseCase{ctrl: ctrl}
	mock.recorder = &MockLeaderboardUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLeaderboardUseCase) EXPECT() *MockLeaderboardUseCaseMockRecorder {
	return m.recorder
}

// GetFullLeaderboard mocks base method.
func (m *MockLeaderboardUseCase) GetFullLeaderboard(ctx context.Context) ([]domain.LeaderboardEntry, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFullLeaderboard", ctx)
	ret0, _ := ret[0].([]domain.LeaderboardEntry)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetFullLeaderboard indicates an expected call of GetFullLeaderboard.
func (mr *MockLeaderboardUseCaseMockRecorder) GetFullLeaderboard(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFullLeaderboard", reflect.TypeOf((*MockLeaderboardUseCase)(nil).GetFullLeaderboard), ctx)
}

// GetLeaderboard mocks base method.
func (m *MockLeaderboardUseCase) GetLeaderboard(ctx context.Context, limit, offset int64) ([]domain.LeaderboardEntry, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLeaderboard", ctx, limit, offset)
	ret0, _ := ret[0].([]domain.LeaderboardEntry)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetLeaderboard indicates an expected call of GetLeaderboard.
func (mr *MockLeaderboardUseCaseMockRecorder) GetLeaderboard(ctx, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLeaderboard", reflect.TypeOf((*MockLeaderboardUseCase)(nil).GetLeaderboard), ctx, limit, offset)
}

// SubscribeToEntryUpdates mocks base method.
func (m *MockLeaderboardUseCase) SubscribeToEntryUpdates(ctx context.Context) (<-chan *domain.LeaderboardEntry, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubscribeToEntryUpdates", ctx)
	ret0, _ := ret[0].(<-chan *domain.LeaderboardEntry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeToEntryUpdates indicates an expected call of SubscribeToEntryUpdates.
func (mr *MockLeaderboardUseCaseMockRecorder) SubscribeToEntryUpdates(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeToEntryUpdates", reflect.TypeOf((*MockLeaderboardUseCase)(nil).SubscribeToEntryUpdates), ctx)
}

// SyncFromPostgres mocks base method.
func (m *MockLeaderboardUseCase) SyncFromPostgres(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SyncFromPostgres", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// SyncFromPostgres indicates an expected call of SyncFromPostgres.
func (mr *MockLeaderboardUseCaseMockRecorder) SyncFromPostgres(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SyncFromPostgres", reflect.TypeOf((*MockLeaderboardUseCase)(nil).SyncFromPostgres), ctx)
}
